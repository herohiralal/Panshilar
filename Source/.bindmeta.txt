$$$PACKAGE_NAME
Panshilar
$$$NAMESPACE
PNSLR
$$$C_CXX_HEADER_PREFIX
#ifndef PNSLR_MAIN_H
#define PNSLR_MAIN_H


$$$C_CXX_HEADER_SUFFIX
/** Create a utf8str from a string literal. */
#define PNSLR_StringLiteral(str) (utf8str) {.count = sizeof(str) - 1, .data = (u8*) str}

/** Get the current source code location. */
#define PNSLR_GET_LOC() (PNSLR_SourceCodeLocation) \
    { \
        .file = PNSLR_StringLiteral(__FILE__), \
        .line = __LINE__, \
        .function = PNSLR_StringLiteral(__FUNCTION__) \
    }

/** Allocate an object of type 'ty' using the provided allocator. */
#define PNSLR_New(ty, allocator, loc, error__) \
    ((ty*) PNSLR_Allocate(allocator, sizeof(ty), alignof(ty), loc, error__))

/** Delete an object allocated with `PNSLR_New`, using the provided allocator. */
#define PNSLR_Delete(obj, allocator, loc, error__) \
    do { if (obj) PNSLR_Free(allocator, obj, loc, error__); } while(0)

/** Allocate an array of 'count' elements of type 'ty' using the provided allocator. Optionally zeroed. */
#define PNSLR_MakeSlice(ty, count, zeroed, allocator, loc, error__) \
    (PNSLR_ArraySlice_##ty) {.raw = PNSLR_MakeRawSlice((i32) sizeof(ty), (i32) alignof(ty), (i64) count, zeroed, allocator, loc, error__)}

/** Free a 'slice' (passed by ptr) allocated with `PNSLR_MakeSlice`, using the provided allocator. */
#define PNSLR_FreeSlice(slice, allocator, loc, error__) \
    do { if (slice) PNSLR_FreeRawSlice(&((slice)->raw), allocator, loc, error__); } while(0)

/** Resize a 'slice' (passed by ptr) to one with 'newCount' elements of type 'ty' using the provided allocator. Optionally zeroed. */
#define PNSLR_ResizeSlice(ty, slice, newCount, zeroed, allocator, loc, error__) \
    do { if (slice) PNSLR_ResizeRawSlice(&((slice)->raw), (i32) sizeof(ty), (i32) alignof(ty), (i64) newCount, zeroed, allocator, loc, error__); } while(0)

#endif//PNSLR_MAIN_H

$$$LAST_VAR_TO_CONSUME_EMPTY_LINE_AT_END
