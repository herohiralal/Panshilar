$$$PACKAGE_NAME
Panshilar
$$$NAMESPACE
PNSLR
$$$C_HEADER_PREFIX
#ifndef PNSLR_MAIN_H
#define PNSLR_MAIN_H


$$$C_HEADER_SUFFIX
/** Create a utf8str from a string literal. */
#define PNSLR_StringLiteral(str) (utf8str) {.count = sizeof(str) - 1, .data = (u8*) str}

/** Get the current source code location. */
#define PNSLR_GET_LOC() (PNSLR_SourceCodeLocation) \
    { \
        .file = PNSLR_StringLiteral(__FILE__), \
        .line = __LINE__, \
        .function = PNSLR_StringLiteral(__FUNCTION__) \
    }

/** Allocate an object of type 'ty' using the provided allocator. */
#define PNSLR_New(ty, allocator, loc, error__) \
    ((ty*) PNSLR_Allocate(allocator, sizeof(ty), alignof(ty), loc, error__))

/** Delete an object allocated with `PNSLR_New`, using the provided allocator. */
#define PNSLR_Delete(obj, allocator, loc, error__) \
    do { if (obj) PNSLR_Free(allocator, obj, loc, error__); } while(0)

/** Allocate an array of 'count' elements of type 'ty' using the provided allocator. Optionally zeroed. */
#define PNSLR_MakeSlice(ty, count, zeroed, allocator, loc, error__) \
    (PNSLR_ArraySlice_##ty) {.raw = PNSLR_MakeRawSlice((i32) sizeof(ty), (i32) alignof(ty), (i64) count, zeroed, allocator, loc, error__)}

/** Free a 'slice' (passed by ptr) allocated with `PNSLR_MakeSlice`, using the provided allocator. */
#define PNSLR_FreeSlice(slice, allocator, loc, error__) \
    do { if (slice) PNSLR_FreeRawSlice(&((slice)->raw), allocator, loc, error__); } while(0)

/** Resize a 'slice' (passed by ptr) to one with 'newCount' elements of type 'ty' using the provided allocator. Optionally zeroed. */
#define PNSLR_ResizeSlice(ty, slice, newCount, zeroed, allocator, loc, error__) \
    do { if (slice) PNSLR_ResizeRawSlice(&((slice)->raw), (i32) sizeof(ty), (i32) alignof(ty), (i64) newCount, zeroed, allocator, loc, error__); } while(0)

#endif//PNSLR_MAIN_H

$$$CXX_HEADER_PREFIX
#ifndef PNSLR_CXX_MAIN_H
#define PNSLR_CXX_MAIN_H


$$$CXX_HEADER_SUFFIX
namespace Panshilar
{
    /** Create a utf8str from a string literal. */
    template <u64 N> constexpr utf8str STRING_LITERAL(const char (&str)[N]) { utf8str output; output.count = (i64) (N - 1); output.data = (u8*) str; return output; }

    /** Get the current source code location. */
    #define PNSLR_GET_LOC() Panshilar::SourceCodeLocation{Panshilar::STRING_LITERAL(__FILE__), __LINE__, 0, Panshilar::STRING_LITERAL(__FUNCTION__)}

    /** Allocate an object of type 'ty' using the provided allocator. */
    template <typename T> T* New(Allocator allocator, SourceCodeLocation loc, AllocatorError* err)
    {
        return (T*) Allocate(allocator, true, (i32) sizeof(T), (i32) alignof(T), loc, err);
    }

    /** Delete an object allocated with `PNSLR_New`, using the provided allocator. */
    template <typename T> void Delete(T* obj, Allocator allocator, SourceCodeLocation loc, AllocatorError* err)
    {
        if (obj) { Free(allocator, obj, loc, err); }
    }

    /** Allocate an array of 'count__' elements of type 'ty' using the provided allocator. Optionally zeroed. */
    template <typename T> ArraySlice<T> MakeSlice(i64 count, b8 zeroed, Allocator allocator, SourceCodeLocation loc, AllocatorError* err)
    {
        RawArraySlice raw = MakeRawSlice((i32) sizeof(T), (i32) alignof(T), count, zeroed, allocator, loc, err);
        return *reinterpret_cast<ArraySlice<T>*>(&raw);
    }

    /** Free a 'slice' allocated with `PNSLR_MakeSlice`, using the provided allocator. Expects a reassignable variable. */
    template <typename T> void FreeSlice(ArraySlice<T>* slice, Allocator allocator, SourceCodeLocation loc, AllocatorError* err)
    {
        if (slice) FreeRawSlice(reinterpret_cast<RawArraySlice*>(slice), allocator, loc, err);
    }

    /** Resize a slice to one with 'newCount__' elements of type 'ty' using the provided allocator. Optionally zeroed. Expects a reassignable variable. */
    template <typename T> void ResizeSlice(ArraySlice<T>* slice, i64 newCount, b8 zeroed, Allocator allocator, SourceCodeLocation loc, AllocatorError* err)
    {
        if (slice) ResizeRawSlice(reinterpret_cast<RawArraySlice*>(slice), (i32) sizeof(T), (i32) alignof(T), newCount, zeroed, allocator, loc, err);
    }
}

#ifdef PNSLR_INTRINSICS_CXX_MAIN_H
    b8 utf8str::operator==(const utf8str& other) const { return Panshilar::AreStringsEqual(*this, other, Panshilar::StringComparisonType::CaseSensitive); }
    b8 utf8str::operator!=(const utf8str& other) const { return !(*this == other); }
#endif

#endif//PNSLR_CXX_MAIN_H

$$$ODN_SRC_SUFFIX
#assert(size_of(int)  == 8, " int must be 8 bytes")
#assert(size_of(uint) == 8, "uint must be 8 bytes")

GET_LOC :: proc(loc := #caller_location) -> SourceCodeLocation {return {file = loc.file_path, line = loc.line, column = loc.column, function = loc.procedure}}

New :: proc($T: typeid, allocator: Allocator, loc: SourceCodeLocation, err: ^AllocatorError) -> ^T {return (^T)(Allocate(allocator, true, size_of(T), align_of(T), loc, err))}

Delete :: proc(obj: ^$T, allocator: Allocator, loc: SourceCodeLocation, err: ^AllocatorError) {if obj != nil {Free(allocator, obj, loc, err)}}

MakeSlice :: proc($T: typeid/[]$E, count: i64, zeroed: b8, allocator: Allocator, loc: SourceCodeLocation, err: ^AllocatorError) -> T {return transmute(T)MakeRawSlice(size_of(E), align_of(E), count, zeroed, allocator, loc, err)}

FreeSlice :: proc(slice: ^[]$T, allocator: Allocator, loc: SourceCodeLocation, err: ^AllocatorError) {if slice != nil {FreeRawSlice(transmute(^RawArraySlice) slice, allocator, loc, err)}}

ResizeSlice :: proc(slice: ^[]$T, newCount: i64, zeroed: b8, allocator: Allocator, loc: SourceCodeLocation, err: ^AllocatorError) {if slice != nil {ResizeRawSlice(transmute(^RawArraySlice) slice, size_of(T), align_of(T), newCount, zeroed, allocator, loc, err)}}

$$$LAST_VAR_TO_CONSUME_EMPTY_LINE_AT_END
